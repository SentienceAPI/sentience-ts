name: Sync Extension from sentience-chrome

on:
  repository_dispatch:
    types: [extension-updated]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag from sentience-chrome (e.g., v1.0.0)'
        required: true
        type: string
  schedule:
    # Check for new releases daily at 2 AM UTC
    - cron: '0 2 * * *'

jobs:
  sync-extension:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      
    steps:
    - name: Checkout sdk-ts
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0  # Fetch all history for proper branching
        
    - name: Set up Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'
        
    - name: Determine release tag
      id: release
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          TAG="${{ github.event.inputs.release_tag }}"
        elif [ "${{ github.event_name }}" == "repository_dispatch" ]; then
          TAG="${{ github.event.client_payload.release_tag }}"
        else
          # Scheduled check - get latest release
          TAG=$(curl -s https://api.github.com/repos/${{ secrets.SENTIENCE_CHROME_REPO }}/releases/latest | jq -r '.tag_name // empty')
        fi
        
        if [ -z "$TAG" ] || [ "$TAG" == "null" ]; then
          echo "No release found, skipping"
          echo "skip=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "tag=$TAG" >> $GITHUB_OUTPUT
        echo "Release tag: $TAG"
        
    - name: Download extension files
      if: steps.release.outputs.skip != 'true'
      run: |
        TAG="${{ steps.release.outputs.tag }}"
        REPO="${{ secrets.SENTIENCE_CHROME_REPO }}"
        
        # Download release assets
        mkdir -p extension-temp
        cd extension-temp
        
        # Download individual files from release (reliable method - no zip)
        echo "üìÅ Downloading individual files from release..."
        echo "Available release assets:"
        curl -s -H "Authorization: token ${{ secrets.SENTIENCE_CHROME_TOKEN }}" \
          "https://api.github.com/repos/$REPO/releases/tags/$TAG" | \
          jq -r '.assets[] | select(.name | endswith(".js") or endswith(".wasm") or endswith(".json") or endswith(".d.ts")) | .name' || true
        
        curl -L -H "Authorization: token ${{ secrets.SENTIENCE_CHROME_TOKEN }}" \
          "https://api.github.com/repos/$REPO/releases/tags/$TAG" | \
          jq -r '.assets[] | select(.name | endswith(".js") or endswith(".wasm") or endswith(".json") or endswith(".d.ts")) | "\(.browser_download_url)|\(.name)"' | \
          while IFS='|' read -r url name; do
            if [ -n "$url" ] && [ "$url" != "null" ] && [ -n "$name" ]; then
              # Handle asset names that might have paths like "pkg/sentience_core.js" or "extension-package/manifest.json"
              # GitHub releases might preserve directory structure in asset names
              # Strip "extension-package/" prefix if present, as we'll handle it in copy step
              if [[ "$name" == extension-package/* ]]; then
                # Asset name is "extension-package/manifest.json" - strip prefix
                filename="${name#extension-package/}"
                dir=$(dirname "$filename")
                if [ "$dir" != "." ]; then
                  mkdir -p "$dir"
                fi
                echo "  Downloading $name -> $filename"
                curl -L -H "Authorization: token ${{ secrets.SENTIENCE_CHROME_TOKEN }}" "$url" -o "$filename"
              elif [[ "$name" == pkg/* ]]; then
                # Asset name is "pkg/sentience_core.js" - create pkg directory
                mkdir -p pkg
                filename=$(basename "$name")
                echo "  Downloading $name -> pkg/$filename"
                curl -L -H "Authorization: token ${{ secrets.SENTIENCE_CHROME_TOKEN }}" "$url" -o "pkg/$filename"
              else
                # Asset name is just "manifest.json" - put at root
                dir=$(dirname "$name")
                if [ "$dir" != "." ]; then
                  mkdir -p "$dir"
                fi
                echo "  Downloading $name"
                curl -L -H "Authorization: token ${{ secrets.SENTIENCE_CHROME_TOKEN }}" "$url" -o "$name"
              fi
            fi
          done
        
        # Verify downloaded files
        echo "üìã Downloaded files structure:"
        find . -type f -name "*.js" -o -name "*.wasm" -o -name "*.json" | sort
        echo ""
        echo "Directory structure:"
        ls -laR . | head -50
        echo ""
        echo "üîç Verifying critical files:"
        if [ -f "manifest.json" ]; then
          echo "‚úÖ manifest.json found ($(wc -c < manifest.json) bytes)"
          head -5 manifest.json
        else
          echo "‚ùå manifest.json NOT FOUND"
        fi
        if [ -d "pkg" ]; then
          echo "‚úÖ pkg directory found with $(ls -1 pkg | wc -l) files"
        else
          echo "‚ùå pkg directory NOT FOUND"
        fi
        
    - name: Copy extension files
      if: steps.release.outputs.skip != 'true'
      run: |
        # Create extension directory structure
        mkdir -p src/extension/pkg
        
        # Copy extension files (handle both root and extension-package/ subdirectory)
        # Check root first, then extension-package/ subdirectory
        if [ -f "extension-temp/manifest.json" ]; then
          size=$(wc -c < extension-temp/manifest.json)
          if [ "$size" -gt 0 ]; then
            echo "‚úÖ Copying manifest.json ($size bytes)"
            cp extension-temp/manifest.json src/extension/
            # Verify copy
            if [ -f "src/extension/manifest.json" ] && [ "$(wc -c < src/extension/manifest.json)" -gt 0 ]; then
              echo "‚úÖ manifest.json copied successfully"
            else
              echo "‚ùå manifest.json copy failed or file is empty"
              exit 1
            fi
          else
            echo "‚ùå manifest.json is empty ($size bytes)"
            exit 1
          fi
        elif [ -f "extension-temp/extension-package/manifest.json" ]; then
          size=$(wc -c < extension-temp/extension-package/manifest.json)
          if [ "$size" -gt 0 ]; then
            echo "‚úÖ Copying manifest.json from extension-package/ ($size bytes)"
            cp extension-temp/extension-package/manifest.json src/extension/
            # Verify copy
            if [ -f "src/extension/manifest.json" ] && [ "$(wc -c < src/extension/manifest.json)" -gt 0 ]; then
              echo "‚úÖ manifest.json copied successfully"
            else
              echo "‚ùå manifest.json copy failed or file is empty"
              exit 1
            fi
          else
            echo "‚ùå manifest.json is empty ($size bytes)"
            exit 1
          fi
        else
          echo "‚ùå manifest.json not found in extension-temp/"
          echo "Available files:"
          find extension-temp -type f | head -20
          exit 1
        fi
        
        if [ -f "extension-temp/content.js" ]; then
          cp extension-temp/content.js src/extension/
        elif [ -f "extension-temp/extension-package/content.js" ]; then
          cp extension-temp/extension-package/content.js src/extension/
        else
          echo "‚ö†Ô∏è content.js not found"
        fi
        
        if [ -f "extension-temp/background.js" ]; then
          cp extension-temp/background.js src/extension/
        elif [ -f "extension-temp/extension-package/background.js" ]; then
          cp extension-temp/extension-package/background.js src/extension/
        else
          echo "‚ö†Ô∏è background.js not found"
        fi
        
        if [ -f "extension-temp/injected_api.js" ]; then
          cp extension-temp/injected_api.js src/extension/
        elif [ -f "extension-temp/extension-package/injected_api.js" ]; then
          cp extension-temp/extension-package/injected_api.js src/extension/
        else
          echo "‚ö†Ô∏è injected_api.js not found"
        fi
        
        # Copy WASM files - try multiple locations and patterns
        echo "üîç Searching for pkg directory and WASM files..."
        
        # Check all possible locations
        if [ -d "extension-temp/pkg" ]; then
          echo "‚úÖ Found pkg directory at extension-temp/pkg"
          cp -r extension-temp/pkg/* src/extension/pkg/ 2>/dev/null || true
        elif [ -d "extension-temp/extension-package/pkg" ]; then
          echo "‚úÖ Found pkg directory at extension-temp/extension-package/pkg"
          cp -r extension-temp/extension-package/pkg/* src/extension/pkg/ 2>/dev/null || true
        else
          echo "‚ö†Ô∏è pkg directory not found, searching for individual files..."
          
          # Search for files in various locations
          find extension-temp -name "sentience_core.js" -type f | while read file; do
            echo "  Found: $file"
            cp "$file" src/extension/pkg/ 2>/dev/null || true
          done
          
          find extension-temp -name "sentience_core_bg.wasm" -type f | while read file; do
            echo "  Found: $file"
            cp "$file" src/extension/pkg/ 2>/dev/null || true
          done
          
          find extension-temp -name "*.d.ts" -type f | while read file; do
            echo "  Found: $file"
            cp "$file" src/extension/pkg/ 2>/dev/null || true
          done
        fi
        
        # Verify copied files
        echo "üìã Copied files:"
        echo "Extension root:"
        ls -la src/extension/ || echo "‚ö†Ô∏è Extension directory empty"
        echo ""
        echo "WASM files (pkg directory):"
        if [ -d "src/extension/pkg" ]; then
          ls -la src/extension/pkg/ || echo "‚ö†Ô∏è pkg directory empty"
        else
          echo "‚ùå ERROR: pkg directory not created!"
          exit 1
        fi
        
        # Verify required files exist
        if [ ! -f "src/extension/pkg/sentience_core.js" ]; then
          echo "‚ùå ERROR: sentience_core.js not found!"
          exit 1
        fi
        if [ ! -f "src/extension/pkg/sentience_core_bg.wasm" ]; then
          echo "‚ùå ERROR: sentience_core_bg.wasm not found!"
          exit 1
        fi
        echo "‚úÖ All required WASM files verified"
        
        # Clean up temporary directory
        cd ..
        rm -rf extension-temp
        echo "üßπ Cleaned up extension-temp directory"
        
    - name: Check for changes
      if: steps.release.outputs.skip != 'true'
      id: changes
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Show what files exist before adding
        echo "üìã Files in src/extension before git add:"
        find src/extension -type f | sort || echo "No files found"
        
        # Add all files including binary files
        # Use -f to force add in case files are in .gitignore
        git add -f src/extension/ || true
        
        # Show what was staged
        echo "üìã Staged files:"
        git diff --staged --name-only || echo "No staged files"
        
        # Check if there are actual changes
        if git diff --staged --quiet; then
          echo "changed=false" >> $GITHUB_OUTPUT
          echo "No changes detected"
        else
          echo "changed=true" >> $GITHUB_OUTPUT
          echo "Changes detected"
          # Show file sizes to verify binary files are included
          echo "üìä Staged file sizes:"
          git diff --staged --name-only | while read file; do
            if [ -f "$file" ]; then
              size=$(ls -lh "$file" | awk '{print $5}')
              echo "  $file: $size"
            fi
          done
        fi
        
    - name: Create Pull Request
      if: steps.release.outputs.skip != 'true' && steps.changes.outputs.changed == 'true'
      uses: peter-evans/create-pull-request@v5
      with:
        # Use PR_TOKEN if available (for repos with org restrictions), otherwise use GITHUB_TOKEN
        # To use PAT: create secret named PR_TOKEN with a Personal Access Token that has 'repo' scope
        token: ${{ secrets.PR_TOKEN }}
        commit-message: "chore: sync extension files from sentience-chrome ${{ steps.release.outputs.tag }}"
        title: "Sync Extension: ${{ steps.release.outputs.tag }}"
        body: |
          This PR syncs extension files from sentience-chrome release ${{ steps.release.outputs.tag }}.
          
          **Files updated:**
          - Extension manifest and scripts
          - WASM binary and bindings
          
          **Source:** [sentience-chrome release ${{ steps.release.outputs.tag }}](https://github.com/${{ secrets.SENTIENCE_CHROME_REPO }}/releases/tag/${{ steps.release.outputs.tag }})
        branch: sync-extension-${{ steps.release.outputs.tag }}
        delete-branch: true
        labels: |
          automated
          extension-sync

